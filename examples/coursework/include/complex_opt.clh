#ifndef __COMPLEX_CLH
#define __COMPLEX_CLH

#pragma OPENCL EXTENSION cl_khr_fp64 : enable

#ifdef cl_khr_fp64
    #define real  double
    #define real2 double2
    #define real4 double4
    #define convert_real2 convert_double2

    #define PI M_PI
    #define UNIT_R2_REAL (-0.5)
    #define UNIT_R2_IMAG (0.866025403784438596)
#else
    #define real  float
    #define real2 float2
    #define real4 float4
    convert_real2 convert_float2

    #define PI M_PI_F
    #define UNIT_R2_REAL (-0.5f)
    #define UNIT_R2_IMAG (0.866025403784438596f)
#endif

#define UNIT_R3_REAL  UNIT_R2_REAL
#define UNIT_R3_IMAG -UNIT_R2_IMAG

inline real2 cmul(real2 a, real2 b) {
    return (real2)(
        a.x*b.x - a.y*b.y,
        a.y*b.x + a.x*b.y
    );
}

// a / b for complex a, b
inline real2 cdiv(real2 a, real2 b) {
    return (real2)(
        (a.x*b.x + a.y*b.y),
        (a.y*b.x - a.x*b.y)
    ) / (b.x*b.x + b.y*b.y);
}

// square root of a for complex a
inline void csqrt(real2 a, real2 roots[]) {
    roots[0].x = sqrt((a.x + length(a)) * 0.5);
    roots[0].y = sign(a.y) * sqrt((-a.x + length(a)) * 0.5);
    roots[1] = -roots[0];
}

// cube root of a for complex a
inline void ccbrt(real2 a, real2 roots[]) {
    const real cbrt_abs_a = cbrt(length(a));
    const real phi = atan2(a.y, a.x) / 3;
    real temp;
    roots[0].y = sincos(phi, &temp) * cbrt_abs_a;
    roots[0].x = temp * cbrt_abs_a;
    roots[1].y = sincos(phi + 2*PI/3, &temp) * cbrt_abs_a;
    roots[1].x = temp * cbrt_abs_a;
    roots[2].y = sincos(phi + 4*PI/3, &temp) * cbrt_abs_a;
    roots[2].x = temp * cbrt_abs_a;
}

// z ** 2 for complex z
inline real2 csq(real2 z) {
    return (real2)(z.x*z.x - z.y*z.y, 2*z.x*z.y);
}

// z ** 3 for complex z
inline real2 ccb(real2 z) {
    return (real2)(
        z.x * (z.x * z.x - 3 * z.y * z.y),
        z.y * (3 * z.x * z.x - z.y * z.y)
    );
}

// Compile-time settings:
// #define SOLVE_CUBIC_B_IS_ZERO - b is considered to be zero. Optimizes out a few multiplications
// #define SOLVE_CUBIC_AVOID_BRANCHES - all roots are always computed
// #define SOLVE_CUBIC_ALPHA_FIT_PRECISION <precision> - set precision for detecting matching alpha/beta

#ifndef SOLVE_CUBIC_ALPHA_FIT_PRECISION
#define SOLVE_CUBIC_ALPHA_FIT_PRECISION (1e-8)
#endif

// Use cardano's formulas to solve cubic equation given in form: z**3 + a*z**2 + b*z + c = 0
// params:
// a, b, c are the (complex) coefficients
// root - which (0, 1, 2) root to compute; -1 if want all roots
// roots - [out] computed roots; if only one root is specified,
// returns 0 if equation was successfully solved, 1 otherwise
int solve_cubic(real2 a, real2 b, real2 c, int root, real2* roots);
int solve_cubic(real2 a, real2 b, real2 c, int root, real2* roots) {
#ifdef SOLVE_CUBIC_AVOID_BRANCHES
    (void)root;
#endif
    // NOTE watch out! input modification
    a /= 3; // need it anyway later
    c /= 2; //
    //
#ifdef SOLVE_CUBIC_B_IS_ZERO
    (void)b;
    const real2 p_div_3 = -csq(a);
    const real2 q_div_2 = ccb(a) + c;
#else
    const real2 p_div_3 = (b - csq(3 * a) / 3) / 3;
    const real2 q_div_2 = cmul(a, b) * 0.5 + ccb(a) + c;
#endif

    const real2 D = csq(q_div_2) + ccb(p_div_3);
    const real2 first_root_of_D = {
                    sqrt((length(D) + D.x) * 0.5),
        sign(D.y) * sqrt((length(D) - D.x) * 0.5)
    };

    real2 alpha[3];
    ccbrt(-q_div_2 - first_root_of_D, alpha);
    real2 beta [3];
    ccbrt(-q_div_2 + first_root_of_D, beta );

    // now we have alpha & beta values, lets combine them such as:
    // alpha[0]*beta[i] = -p / 3;
    int i;
    {
        i = 0;
        const real2 v = alpha[0] * beta[i].x + (real2)(-alpha[0].y, alpha[0].x) * beta[i].y + p_div_3;
        if (all(fabs(v) < SOLVE_CUBIC_ALPHA_FIT_PRECISION)) {
            goto beta_found;
        }
    }
    {
        i = 1;
        const real2 v = alpha[0] * beta[i].x + (real2)(-alpha[0].y, alpha[0].x) * beta[i].y + p_div_3;
        if (all(fabs(v) < SOLVE_CUBIC_ALPHA_FIT_PRECISION)) {
            goto beta_found;
        }
    }
    {
        i = 2;
        const real2 v = alpha[0] * beta[i].x + (real2)(-alpha[0].y, alpha[0].x) * beta[i].y + p_div_3;
        if (all(fabs(v) < SOLVE_CUBIC_ALPHA_FIT_PRECISION)) {
            goto beta_found;
        }
    }

    // cannot find b, such that alpha*beta = p/3 (although it should always exists);
    // maybe floating point error is greater than precision, but better not to risk and report error
    return 1;

beta_found:
    // now corresponding beta is found for alpha[0]. other betas can be inferred from it

#ifdef SOLVE_CUBIC_AVOID_BRANCHES
    // alpha_1 + beta_1 - a/3
    roots[0] = alpha[0] - a + beta[i];
    // alpha_2 + beta_3 - a/3
    roots[1] = alpha[1] - a + beta[i] * UNIT_R3_REAL;
    roots[1].x -= UNIT_R3_IMAG*beta[i].y;
    roots[1].y += UNIT_R3_IMAG*beta[i].x;
    // alpha_3 + beta_2 - a/3
    roots[2] = alpha[2] - a + beta[i] * UNIT_R2_REAL;
    roots[2].x -= UNIT_R2_IMAG*beta[i].y;
    roots[2].y += UNIT_R2_IMAG*beta[i].x;
#else
    if (root == 0 || root == -1) {
        // alpha_1 + beta_1 - a/3
        roots[0] = alpha[0] - a + beta[i];
    }
    if (root == 1 || root == -1) {
        // alpha_2 + beta_3 - a/3
        roots[1] = alpha[1] - a + beta[i] * UNIT_R3_REAL;
        roots[1].x -= UNIT_R3_IMAG*beta[i].y;
        roots[1].y += UNIT_R3_IMAG*beta[i].x;
    }
    if (root == 2 || root == -1) {
        // alpha_3 + beta_2 - a/3
        roots[2] = alpha[2] - a + beta[i] * UNIT_R2_REAL;
        roots[2].x -= UNIT_R2_IMAG*beta[i].y;
        roots[2].y += UNIT_R2_IMAG*beta[i].x;
    }
#endif
    return 0;
}

#endif // __COMPLEX_CLH
