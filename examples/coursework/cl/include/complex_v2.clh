#pragma OPENCL EXTENSION cl_khr_fp64 : enable

#ifdef cl_khr_fp64
    #define real  double
    #define real2 double2
    #define real4 double4
    #define convert_real2 convert_double2

    #define PI M_PI
#else
    #define real  float
    #define real2 float2
    #define real4 float4
    #define convert_real2 convert_float2

    #define PI M_PI_F
#endif

#define IS_REAL_CHECK_THRESHOLD 1e-96

#define SQRT_3_DIV_2 0.866025403784438596
#define UNITY_ROOT_1 (real2)(-.5, +SQRT_3_DIV_2)
#define UNITY_ROOT_2 (real2)(-.5, -SQRT_3_DIV_2)

// a / b for complex a, b
inline real2 cdiv(real2 a, real2 b) {
    return (real2)(
        (a.x*b.x + a.y*b.y),
        (a.y*b.x - a.x*b.y)
    ) / (b.x*b.x + b.y*b.y);
}

// a * b for complex a, b
inline real2 cmul(real2 a, real2 b) {
    return (real2)(
        a.x*b.x - a.y*b.y, a.y*b.x + a.x*b.y
    );
}

// z ** 2 for complex z
inline real2 csq(real2 z) {

    return (real2)(z.x*z.x - z.y*z.y, 2*z.x*z.y);
}

// z ** 3 for complex z
inline real2 ccb(real2 z) {
    return (real2)(
        z.x * (z.x * z.x - 3 * z.y * z.y),
        z.y * (3 * z.x * z.x - z.y * z.y)
    );
}

// z ** (1/2) for complex z (principal)
inline real2 csqrt1(real2 x) {
    return (real2)(
        sqrt((length(x) + x.x) / 2),
        sign(x.y) * sqrt((length(x) - x.x) / 2)
    );
}

// z ** (1/3) for complex z (principal)
inline real2 ccbrt1(real2 x) {
    real phi = atan2(x.y, x.x) / 3;
    real cp; real sp = sincos(phi, &cp);
    return cbrt(length(x)) * (real2)(cp, sp);
}

// checks if complex number is real
inline int is_real(real2 x) {

    return fabs(x.y) <= IS_REAL_CHECK_THRESHOLD;
}

// TODO optimize solve_cubic functions
// probably should be merge into single function. also pay
// attention to things such as multiplying by unity root

// solve_cubic -- general case
void solve_depressed_cubic(real2 p, real2 q, real2 roots[3]) {
    q /= 2;

    const real2 d = csqrt1(csq(q) + ccb(p / 3));

    real2 u1 = ccbrt1(-q + d);
    real2 v1 = ccbrt1(-q - d);

    roots[0] = u1 + v1;

    u1 = cmul(u1, UNITY_ROOT_1);
    v1 = cmul(v1, UNITY_ROOT_2);
    roots[1] = u1 + v1;

    u1 = cmul(u1, UNITY_ROOT_1);
    v1 = cmul(v1, UNITY_ROOT_2);
    roots[2] = u1 + v1;
}

// solve_cubic -- real p, q
void solve_depressed_real_cubic(real p, real q, real2 roots[3]) {
    real d = q*q / 4 + p*p*p / 27;
    if        (d > 0) { // "classical" case
        d = sqrt(d);
        real u1 = cbrt(-q / 2 + d);
        real v1 = cbrt(-q / 2 - d);
        roots[0] = (real2)(u1 + v1, 0);
        roots[1] = (real2)(-(u1 + v1) / 2, +(u1 - v1) * SQRT_3_DIV_2);
        roots[2] = (real2)(-(u1 + v1) / 2, -(u1 - v1) * SQRT_3_DIV_2);
    } else if (d < 0) { // "irreducible" case
        const real acs = acos(3 * q / (2 * p) * sqrt(-3 / p)) / 3;
        for (int i = 0; i < 3; ++i) {
            roots[i] = (real2)(
                2*sqrt(-p / 3)*cos(acs + 2*i*PI / 3)
            , 0);
        }
    } else { // d == 0  // "vanishing" discriminant
        const real qcb = cbrt(q / 2);
        roots[0] = (real2)(qcb, 0);
        roots[1] = (real2)(qcb, 0);
        roots[2] = (real2)(-2 * qcb, 0);
    }
}

// solves cubic equation given in form z**3 + a*z**2 + b*z + c = 0
void solve_cubic(real2, real2, real2, real2[3]);
void solve_cubic(real2 a, real2 b, real2 c, real2 roots[3]) {
    const real2 p = b - csq(a) / 3;
    const real2 q = (2 * ccb(a) - 9 * cmul(a, b)) / 27 + c;

    if (is_real(p) && is_real(q)) {
        solve_depressed_real_cubic(p.x, q.x, roots);
    } else {
        solve_depressed_cubic(p, q, roots);
    }

    roots[0] -= a / 3;
    roots[1] -= a / 3;
    roots[2] -= a / 3;
}
