#ifndef __COMPLEX_CLH
#define __COMPLEX_CLH

#pragma OPENCL EXTENSION cl_khr_fp64 : enable

#ifdef cl_khr_fp64
    #define real  double
    #define real2 double2
    #define real4 double4
    #define convert_real2 convert_double2

    #define PI M_PI
    #define UNIT_R2_REAL (-0.5)
    #define UNIT_R2_IMAG (0.866025403784438596)
#else
    #define real  float
    #define real2 float2
    #define real4 float4
    #define convert_real2 convert_float2

    #define PI M_PI_F
    #define UNIT_R2_REAL (-0.5f)
    #define UNIT_R2_IMAG (0.866025403784438596f)
#endif

#define UNIT_R3_REAL  UNIT_R2_REAL
#define UNIT_R3_IMAG -UNIT_R2_IMAG

// a / b for complex a, b
inline real2 cdiv(real2 a, real2 b) {
    return (real2)(
        (a.x*b.x + a.y*b.y),
        (a.y*b.x - a.x*b.y)
    ) / (b.x*b.x + b.y*b.y);
}

// square root of a for complex a
inline void csqrt(real2 a, real2 roots[]) {
    roots[0].x = sqrt((a.x + length(a)) / 2);
    roots[0].y = sign(a.y) * sqrt((-a.x + length(a)) / 2);
    roots[1] = -roots[0];
}

// cube root of a for complex a
inline void ccbrt(real2 a, real2 roots[]) {
    real cbrt_abs_a = cbrt(length(a));
    real phi = atan2(a.y, a.x) / 3.0;
    real temp = 0;
    roots[0].y = sincos(phi, &temp) * cbrt_abs_a;
    roots[0].x = temp * cbrt_abs_a;
    roots[1].y = sincos(phi + 2*PI/3.0, &temp) * cbrt_abs_a;
    roots[1].x = temp * cbrt_abs_a;
    roots[2].y = sincos(phi + 4*PI/3.0, &temp) * cbrt_abs_a;
    roots[2].x = temp * cbrt_abs_a;
}

// z ** 2 for complex z
inline real2 csq(real2 z) {

    return (real2)(z.x*z.x - z.y*z.y, 2*z.x*z.y);
}

// z ** 3 for complex z
inline real2 ccb(real2 z) {
    return (real2)(
        z.x * (z.x*z.x - z.y*z.y - 2*z.y*z.y),
        z.y * (2*z.x*z.x + z.x*z.x - z.y*z.y)
    );
}


#ifndef SOLVE_CUBIC_ALPHA_FIT_PRECISION
#define SOLVE_CUBIC_ALPHA_FIT_PRECISION (1e-10)
#endif

// uses cardano's formulas to solve cubic equation given in form: z**3 + a*z**2 + b*z + c = 0
// params:
// a, b, c are the coefficients
// root - which (0, 1, 2) root to compute; -1 if want all roots
// roots - [out] computed roots; if only one root is specified,
// returns 0 if equation was successfully solved, 1 otherwise
int solve_cubic(real2 a, real2 b, real2 c, int root, real2* roots);
int solve_cubic(real2 a, real2 b, real2 c, int root, real2* roots) {
    real2 p = {
        b.x - (a.x*a.x - a.y*a.y) / 3.0,
        b.y - a.x*a.y * (2.0 / 3.0)
    };
    real2 q = {
        c.x + a.x * (a.x*a.x - 3*a.y*a.y) * (2.0 / 27) - (a.x*b.x - a.y*b.y) / 3.0,
        c.y + a.y * (3*a.x*a.x - a.y*a.y) * (2.0 / 27) - (a.y*b.x + a.x*b.y) / 3.0
    };
    real2 D = {
        (q.x*q.x - q.y*q.y) / 4 + p.x * (p.x*p.x - 3*p.y*p.y) / 27.0,
        q.x*q.y / 2.0 + p.y * (3*p.x*p.x - p.y*p.y) / 27.0
    };
    real modulus = length(D);
    real2 first_root_of_D = {
        sqrt((D.x + modulus) / 2),
        sign(D.y) * sqrt((modulus - D.x) / 2)
    };
    real2 base_alpha = {
        -q.x / 2.0 - first_root_of_D.x,
        -q.y / 2.0 - first_root_of_D.y
    };
    real2 alpha[3];
    ccbrt(base_alpha, alpha);
    real2 base_beta = {
        -q.x / 2.0 + first_root_of_D.x,
        -q.y / 2.0 + first_root_of_D.y
    };
    real2 beta[3];
    ccbrt(base_beta, beta);
    // now we have alpha & beta values, lets combine them such as:
    // alpha[0]*beta[i] = -p / 3;
    int idx = -1;
    for (int i = 0; i < 3; ++i) {
        if (fabs( alpha[0].x*beta[i].x - alpha[0].y*beta[i].y + p.x / 3 ) < SOLVE_CUBIC_ALPHA_FIT_PRECISION &&
            fabs( alpha[0].y*beta[i].x + alpha[0].x*beta[i].y + p.y / 3 ) < SOLVE_CUBIC_ALPHA_FIT_PRECISION) {
            idx = i;
            break;
        }
    }
    if (idx == -1) {
        // cannot find b, such that alpha*beta = p/3 (although it should always exists);
        // maybe floating point error is greater than precision, but better not to risk and report error
        return 1;
    }
    // now corresponding beta is found for alpha[0]. other betas can be inferred from it
    if (root <= 0) {
        // alpha_1 + beta_1 - a/3
        roots[0] = alpha[0] + beta[idx] - a / 3.0f;
    }
    if (root == 1 || root == -1) {
        // alpha_2 + beta_3 - a/3
        roots[1].x = alpha[1].x - a.x / 3.0 + UNIT_R3_REAL*beta[idx].x - UNIT_R3_IMAG*beta[idx].y;
        roots[1].y = alpha[1].y - a.y / 3.0 + UNIT_R3_REAL*beta[idx].y + UNIT_R3_IMAG*beta[idx].x;
    }
    if (root == 2 || root == -1) {
        // alpha_3 + beta_2 - a/3
        roots[2].x = alpha[2].x - a.x / 3.0 + UNIT_R2_REAL*beta[idx].x - UNIT_R2_IMAG*beta[idx].y;
        roots[2].y = alpha[2].y - a.y / 3.0 + UNIT_R2_REAL*beta[idx].y + UNIT_R2_IMAG*beta[idx].x;
    }
    return 0;
}

#endif // __COMPLEX_CLH
